// Helper macros, don't use these. instead use the readX and writeX macros below
#define write_iomem8(reg, val)                                  \
    *(mmio + reg) = val

#define read_iomem8(reg)                                        \
    ({                                                          \
       uint8_t val;                                             \
       val = *(mmio + reg);                                     \
       val;                                                     \
    })

#define write_iomem16(reg, val)                                 \
    *((uint16_t *)(mmio + reg)) = val

#define read_iomem16(reg)                                       \
    ({                                                          \
       uint16_t val;                                            \
       val = *((uint16_t *)(mmio + reg));                       \
       val;                                                     \
    })

#define write_iomem32(reg, val)                                 \
    *((uint32_t *)(mmio + reg)) = val

#define read_iomem32(reg)                                       \
    ({                                                          \
       uint32_t val;                                            \
       val = *((uint32_t *)(mmio + reg));                       \
       val;                                                     \
    })

// Use these to read / write to the MMIO regions
#define read1(reg)                                         \
    read_iomem8(reg)

#define write1(reg, val  )                                 \
    write_iomem8(reg, val)

#define read2(reg)                                         \
    read_iomem16(reg)

#define write2(reg, val)                                   \
    write_iomem16(reg, val)

#define read4(reg)                                         \
    read_iomem32(reg)

#define write4(reg, val)                                   \
    write_iomem32(reg, val)

// Helpers to deal with physical memory
//
// File descriptors
int mem, pagemap;

// Sections 2.2 and 2.3 from
// http://phrack.org/papers/vm-escape-qemu-case-study.html
//
// The important function here is `gva_to_gpa`, which allows you to convert a
// QEMU guest virtual address (gva) to a guest physical address (gpa).
#define PAGE_SHIFT  12
#define PAGE_SIZE   (1 << PAGE_SHIFT)
#define PFN_PRESENT (1ull << 63)
#define PFN_PFN     ((1ull << 55) - 1)

uint32_t page_offset(uint32_t addr)
{
    return addr & ((1 << PAGE_SHIFT) - 1);
}

uint64_t gva_to_gfn(void *addr)
{
    uint64_t pme, gfn;
    size_t offset;
    offset = ((uintptr_t)addr >> 9) & ~7;
    lseek(pagemap, offset, SEEK_SET);
    read(pagemap, &pme, 8);
    if (!(pme & PFN_PRESENT))
        return -1;
    gfn = pme & PFN_PFN;
    return gfn;
}

uint64_t gva_to_gpa(void *addr)
{
    if (!pagemap) {
        pagemap = open("/proc/self/pagemap", O_RDONLY);

        if (pagemap == -1) {
            printf("[!] Cannot open /proc/self/pagemap!\n");
            exit(-1);
        }
    }

    uint64_t gfn = gva_to_gfn(addr);
    return (gfn << PAGE_SHIFT) | page_offset((uint64_t)addr);
}

// This function is used to map most physical addresses into the binary's
// virtual address space. Mostly useful for mapping MMIO regions.
//
// https://github.com/renorobert/virtualbox-cve-2018-2844/blob/master/exploit.c
uint8_t *map_phy_address(off_t address, size_t size)
{
	uint8_t *map;

	if (!mem)
		mem = open("/dev/mem", O_RDWR | O_SYNC);

	map = mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED,
			mem, address);
	return map;
}

// See https://wiki.osdev.org/PCI#Command_Register
//
// Bus Master mode is a bit in the PCI configuration space of all PCI devices.
// It needs to be enabled to allow the PCI device to generate it's own DMA
// accesses.
//
// Note that although this is set by default in most cases, I've found that at
// least in QEMU, you have to enable this manually.
void enable_bus_master_mode() {
    // We need to flip the 3rd bit at offset 4 of the PCI configuration space
    // to enable Bus Master mode
    uint8_t buf[1] = {0x7};
    
    // Replace the path here with your corresponding PCI device in sysfs
    int fd = open("/sys/devices/pci0000:00/0000:00:03.0/config", O_RDWR | O_SYNC);
    pwrite(fd, &buf, 1, 4);
    close(fd);
}
